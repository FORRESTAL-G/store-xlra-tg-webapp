<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Outsmart Genesis Store</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-bg: #000000;
            --tg-text: #ffffff;
            --palladium: rgba(180, 185, 190, 0.6);
            --card-width: 220px;
            --card-height: 280px;
            --item-gap: 20px;
            --vertical-gap: 200px;
            --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);
            --duration: 0.5s;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--tg-bg);
            color: var(--tg-text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding-top: var(--safe-top);
            padding-left: var(--safe-left);
            padding-right: var(--safe-right);
            border-top-left-radius: 22px;
            border-top-right-radius: 22px;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--tg-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border-top-color: var(--tg-text);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .stage {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: visible;
            cursor: grab;
            touch-action: none;
            padding-bottom: var(--safe-bottom);
        }

        .stage.active {
            cursor: grabbing;
        }

        .item {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: transform var(--duration) var(--ease-out-expo), opacity var(--duration) ease, filter var(--duration) ease;
            will-change: transform;
            left: 0;
            top: 0;
        }

        .item.active {
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
        }

        .img-container {
            width: 160px;
            height: 160px;
            background: transparent;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: visible;
            cursor: pointer;
            border: 0.5px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s ease;
            flex-shrink: 0;
            position: relative;
        }

        .img-container::before {
            content: '';
            position: absolute;
            inset: -20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(180, 200, 255, 0.3), transparent 70%);
            z-index: -1;
            animation: glow-pulse 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes glow-pulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(0.95);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        .img-container:hover {
            border-color: rgba(255, 255, 255, 0.15);
        }

        .img-container:hover::before {
            opacity: 0.9;
        }

        .item-img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            z-index: 1;
            position: relative;
        }

        .bonus-ribbon {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0) 0%, rgba(255, 215, 0, 0.6) 20%, rgba(255, 215, 0, 0.8) 50%, rgba(255, 215, 0, 0.6) 80%, rgba(255, 215, 0, 0) 100%);
            color: #fff;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 1px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 10;
            pointer-events: none;
            text-transform: uppercase;
            box-shadow: 0 2px 10px rgba(255, 215, 0, 0.2);
        }

        .info-panel {
            opacity: 0;
            transition: all var(--duration) ease;
            pointer-events: none;
            text-align: center;
            max-width: 240px;
            display: none;
        }

        .item.active .info-panel {
            display: block;
            margin-left: 24px;
            text-align: left;
            width: 320px;
            min-width: 320px;
        }

        .title {
            font-size: 1.3em;
            font-weight: 800;
            margin-bottom: 12px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: 0.3px;
            color: #fff;
            text-align: center;
        }

        .item.active .title {
            text-align: left;
        }

        .desc {
            font-size: 0.9em;
            color: #bbb;
            line-height: 1.5;
            text-align: center;
            margin-bottom: 0;
        }

        .item.active .desc {
            text-align: left;
        }

        .lore-divider {
            width: 100%;
            height: 0.5px;
            background: linear-gradient(90deg, transparent 0%, rgba(180, 185, 190, 0.15) 50%, transparent 100%);
            margin: 14px 0 10px 0;
        }

        .lore-quote {
            font-family: 'Times New Roman', Georgia, serif;
            font-style: italic;
            font-size: 10px;
            line-height: 1.4;
            color: var(--palladium);
            text-align: left;
            opacity: 0.7;
            max-height: 80px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 4px;
            pointer-events: auto;
            touch-action: pan-y;
        }

        .lore-quote::-webkit-scrollbar {
            width: 3px;
        }

        .lore-quote::-webkit-scrollbar-track {
            background: transparent;
        }

        .lore-quote::-webkit-scrollbar-thumb {
            background: rgba(180, 185, 190, 0.3);
            border-radius: 2px;
        }

        .lore-quote::-webkit-scrollbar-thumb:hover {
            background: rgba(180, 185, 190, 0.5);
        }

        .item.active .info-panel {
            opacity: 1;
            transform: translateX(0);
        }

        /* ---- PARTICLES 6 LIVELLI ---- */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            animation: float-up linear infinite;
        }

        /* Livello 1: Tiny - lontanissime, lentissime */
        .particle.tiny {
            background: radial-gradient(circle, rgba(220, 230, 240, 0.4), transparent);
            opacity: 0.2;
        }

        /* Livello 2: Small - lontane, lente */
        .particle.small {
            background: radial-gradient(circle, rgba(230, 240, 250, 0.5), transparent);
            opacity: 0.3;
        }

        /* Livello 3: Medium-small */
        .particle.medium-small {
            background: radial-gradient(circle, rgba(235, 245, 255, 0.6), rgba(200, 210, 220, 0.3), transparent);
            opacity: 0.5;
        }

        /* Livello 4: Medium-large */
        .particle.medium-large {
            background: radial-gradient(circle, rgba(240, 250, 255, 0.7), rgba(210, 220, 230, 0.4), transparent);
            opacity: 0.6;
        }

        /* Livello 5: Large - vicine */
        .particle.large {
            background: radial-gradient(circle, rgba(245, 250, 255, 0.8), rgba(220, 230, 240, 0.4), transparent);
            filter: blur(1px);
            opacity: 0.4;
        }

        /* Livello 6: Huge - vicinissime, velocissime, sfocate */
        .particle.huge {
            background: radial-gradient(circle, rgba(250, 255, 255, 0.6), transparent);
            filter: blur(3px);
            opacity: 0.3;
        }

        @keyframes float-up {
            0% {
                transform: translateY(0) translateX(0) scale(var(--start-scale));
                opacity: 0;
            }
            15% {
                opacity: var(--max-opacity);
            }
            85% {
                opacity: calc(var(--max-opacity) - 0.6);
            }
            100% {
                transform: translateY(-110vh) translateX(var(--drift)) scale(var(--end-scale));
                opacity: 0;
            }
        }

        /* Audio control */
        .audio-control {
            position: fixed;
            bottom: calc(20px + var(--safe-bottom));
            right: calc(20px + var(--safe-right));
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 50;
        }

        .volume-slider {
            width: 40px;
            height: 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            margin-bottom: 8px;
            padding: 0;
            overflow: hidden;
            transition: height 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        .volume-slider.visible {
            height: 120px;
            padding: 12px 0;
            opacity: 1;
            pointer-events: auto;
        }

        .volume-track {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            position: relative;
            cursor: pointer;
        }

        .volume-fill {
            width: 4px;
            height: 50%;
            background: linear-gradient(to top, rgba(160, 160, 160, 0.8), rgba(200, 200, 200, 0.9));
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .audio-toggle {
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .audio-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .audio-toggle.playing {
            border-color: rgba(160, 160, 160, 0.6);
        }

        /* Balance Counter */
        .balance-counter {
            position: fixed;
            top: calc(20px + var(--safe-top));
            right: calc(20px + var(--safe-right));
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 0.5px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 8px 14px 8px 10px;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .balance-counter:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .balance-icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
            filter: drop-shadow(0 0 4px rgba(180, 200, 255, 0.4));
        }

        .balance-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--palladium);
            letter-spacing: 0.5px;
            min-width: 40px;
            text-align: right;
        }

        @media (max-width: 600px) {
            .balance-counter {
                padding: 6px 12px 6px 8px;
                gap: 6px;
            }

            .balance-icon {
                width: 20px;
                height: 20px;
            }

            .balance-value {
                font-size: 12px;
                min-width: 35px;
            }
        }

        @media (max-width: 600px) {
            :root {
                --card-width: 160px;
                --card-height: 220px;
                --item-gap: 15px;
                --vertical-gap: 180px;
            }

            .img-container {
                width: 110px;
                height: 110px;
            }

            .img-container::before {
                inset: -15px;
            }

            .item.active .info-panel {
                width: 220px;
                min-width: 220px;
                margin-left: 16px;
            }

            .title {
                font-size: 1.1em;
            }

            .desc {
                font-size: 0.8em;
            }

            .lore-quote {
                font-size: 9px;
                max-height: 70px;
            }

            .bonus-ribbon {
                top: 10px;
                font-size: 9px;
                height: 20px;
            }
        }

        @media (max-width: 400px) {
            :root {
                --card-width: 140px;
                --card-height: 200px;
                --item-gap: 12px;
            }

            .img-container {
                width: 95px;
                height: 95px;
            }

            .img-container::before {
                inset: -12px;
            }

            .item.active .info-panel {
                width: 200px;
                min-width: 200px;
                margin-left: 12px;
            }

            .lore-quote {
                font-size: 8px;
                max-height: 60px;
            }

            .bonus-ribbon {
                top: 8px;
                font-size: 8px;
                height: 18px;
            }
        }
    </style>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
    </div>

    <div id="stage" class="stage"></div>

    <div class="particles" id="particles"></div>

    <div class="balance-counter">
        <img src="assets/imgs/1.png" alt="Balance" class="balance-icon">
        <div class="balance-value" id="balanceValue">0</div>
    </div>

    <div class="audio-control">
        <div class="volume-slider" id="volumeSlider">
            <div class="volume-track" id="volumeTrack">
                <div class="volume-fill" id="volumeFill"></div>
            </div>
        </div>
        <div class="audio-toggle" id="audioToggle" title="Toggle Volume">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        </div>
    </div>

    <audio id="bgAudio" preload="auto"></audio>

    <script>
        const tg = window.Telegram?.WebApp;
        let isTelegram = false;
        let validatedUser = null;

        const CONFIG = {
            webhooks: {
                validate: 'https://vp75.app.n8n.cloud/webhook/468awf86g4g168d4hdgd4g84163a5wd878s41/telegram-validate',
                checkBonus: 'https://vp75.app.n8n.cloud/webhook/60e82333-89fc-4718-84a8-3acb29be720a/check-bonus',
                topUp: 'https://vp75.app.n8n.cloud/webhook/8fa65d84-e5e5-41eb-80e8-1e5afa6e6b91/top-up'
            },
            products: [
                { id: 1, price: 50, credits: 400, nameIt: 'Genesi x400', nameEn: 'Genesis x400' },
                { id: 2, price: 250, credits: 2300, nameIt: 'Genesi x2300', nameEn: 'Genesis x2300' },
                { id: 3, price: 1000, credits: 10500, nameIt: 'Genesi x10500', nameEn: 'Genesis x10500' }
            ],
            descriptions: {
                it: 'Orb della Genesi - energia pura necessaria alla manifestazione della tua strategia.',
                en: 'Genesis Orb - pure energy necessary to manifest your communication strategy.'
            },
            loreQuote: {
                it: 'Un saggio una volta disse: "Il cielo non crea una persona sopra o sotto un\'altra." Ma questa non è tutta la citazione. Prosegue dicendo che "Sebbene siamo tutti uguali alla nascita, presto le cose iniziano a cambiare. Lo sforzo accademico è ciò che distingue alcune persone per elevarsi sopra le altre." Ad ogni modo, gli esseri umani cambiano nel tempo in base alle loro azioni. A dire il vero--alla fine--l\'uguaglianza è solo una fantasia, e la maggior parte di noi attraversa la vita negando il fatto che viviamo in una meritocrazia.',
                en: 'A wise man once said: "Heaven does not create one person above or below another." But that is not the whole quote. He goes on to say that "While we are all equal at birth, pretty soon things begin to change. Academic effort is what sets some people apart to rise above the other." At any rate, humans change over time based on their actions. Truth be told--at the end of the day--equality is just a fantasy, and most of us go through life denying the fact that we live in a meritocracy.'
            }
        };

        function parseBonus(assetCode) {
            if (!assetCode || !assetCode.includes('b')) return null;

            return {
                multiplier: 'X2',
                extraCredits:
                    assetCode.startsWith('1') ? 400 :
                    assetCode.startsWith('2') ? 2300 :
                    10500
            };
        }        

        // Shimmer sound - UI Click soft
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playShimmer() {
            try {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.05);
                gainNode.gain.setValueAtTime(0.02, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.05);
            } catch (e) {
                console.log('Shimmer error:', e);
            }
        }

        function updateMainButton() {
            if (!tg) return;
            if (state.mode === 'focused') {
                const currentItem = state.items[state.activeIndex];
                const priceText = currentItem.data.price + ' CHF';
                tg.MainButton.setText('ACQUISTA - ' + priceText);
                tg.MainButton.color = '#1a1a1a';
                tg.MainButton.textColor = '#b4b9be';
                tg.MainButton.show();
            } else {
                tg.MainButton.hide();
            }
        }

        if (tg) {
            tg.MainButton.onClick(async () => {
                if (state.mode !== 'focused') return;
                if (!validatedUser) return;

                const currentItem = state.items[state.activeIndex];
                const userId = validatedUser.id;

                try {
                    const response = await fetch(CONFIG.webhooks.topUp, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chatid: userId,
                            productid: currentItem.asset,
                            language_code: validatedUser.language_code
                        })
                    });

                    if (!response.ok) {
                        console.error('Purchase failed:', response.status);
                        return;
                    }

                    const data = await response.json();
                    const link = data?.response?.link;

                    if (!link) {
                        console.error('No link returned by webhook');
                        return;
                    }

                    // ✅ TELEGRAM WEBAPP
                    if (tg?.openLink) {
                        tg.openLink(link);
                    }
                    // ✅ FALLBACK BROWSER NORMALE
                    else {
                        window.open(link, '_blank', 'noopener,noreferrer');
                    }

                } catch (error) {
                    console.error('Purchase error:', error);
                }
            });
        }

        async function validateTelegramUser() {
            if (!tg || !tg.initData) return null;

            try {
                const response = await fetch(CONFIG.webhooks.validate, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ initData: tg.initData })
                });

                if (!response.ok) throw new Error('Validation failed');

                const data = await response.json();
                const payload = Array.isArray(data) ? data[0] : data;

                if (payload?.valid && payload?.user) {
                    return payload.user;
                }

                return null;
            } catch (error) {
                console.error('Telegram validation error:', error);
                return null;
            }
        }


        async function checkBonusStatus(userId) {
            try {
                const response = await fetch(`${CONFIG.webhooks.checkBonus}?userId=${userId}`);
                if (!response.ok) throw new Error('Bonus check failed');

                const data = await response.json();
                return data.response || data;
            } catch (error) {
                console.error('Bonus check error:', error);
                return null;
            }
        }

        if (tg && tg.initData) {
            tg.ready();
            tg.expand();
            isTelegram = true;

            const themeParams = tg.themeParams;
            const bgColor = themeParams.bgcolor || '#000000';
            document.documentElement.style.setProperty('--tg-bg', bgColor);
            document.body.style.backgroundColor = bgColor;
        }

        let state = {
            mode: 'default',
            activeIndex: 1,
            items: [],
            isDragging: false,
            startX: 0,
            velocity: 0,
            balance: 0
        };

        function updateBalanceDisplay(balance) {
            const balanceEl = document.getElementById('balanceValue');
            if (balanceEl) {
                const formatted = balance.toLocaleString('it-IT');
                balanceEl.textContent = formatted;
                console.log('Balance updated:', formatted);
            }
        }

        function getComputedDimensions() {
            const root = getComputedStyle(document.documentElement);
            return {
                cardW: parseFloat(root.getPropertyValue('--card-width')),
                cardH: parseFloat(root.getPropertyValue('--card-height')),
                gap: parseFloat(root.getPropertyValue('--item-gap')),
                vGap: parseFloat(root.getPropertyValue('--vertical-gap'))
            };
        }

        function calculateLayout() {
            const stage = document.getElementById('stage');
            const stageRect = stage.getBoundingClientRect();
            const dim = getComputedDimensions();

            const centerX = stageRect.width / 2;
            const centerY = stageRect.height / 2;

            const computedImg = window.innerWidth < 400 ? 95 : (window.innerWidth < 600 ? 110 : 160);

            state.items.forEach((item, i) => {
                const el = item.el;
                const isActive = i === state.activeIndex;

                if (state.mode === 'default') {
                    const offsetX = (i - state.activeIndex) * (computedImg + dim.gap);
                    const x = centerX - computedImg / 2 + offsetX;
                    const y = centerY - computedImg / 2;

                    el.style.transform = `translate(${x}px, ${y}px)`;
                    el.style.opacity = isActive ? 1 : 0.9;
                    el.style.filter = 'none';
                    el.classList.remove('active');
                } else if (isActive) {
                    const textWidth = window.innerWidth < 400 ? 200 : (window.innerWidth < 600 ? 220 : 320);
                    const margin = window.innerWidth < 400 ? 12 : (window.innerWidth < 600 ? 16 : 24);
                    const totalWidth = computedImg + margin + textWidth;

                    const x = centerX - totalWidth / 2;
                    const y = centerY - computedImg / 2;

                    el.style.transform = `translate(${x}px, ${y}px) scale(1)`;
                    el.style.opacity = 1;
                    el.style.filter = 'none';
                    el.classList.add('active');
                } else {
                    const distance = i - state.activeIndex;
                    const x = centerX - computedImg / 2 + distance * dim.vGap;
                    const y = centerY - computedImg / 2;

                    el.style.transform = `translate(${x}px, ${y}px) scale(0.85)`;
                    el.style.opacity = 0.3;
                    el.style.filter = 'blur(3px) grayscale(70%)';
                    el.classList.remove('active');
                }
            });

            updateMainButton();
        }

        function changeFocus(direction) {
            const next = state.activeIndex + direction;

            if (next < 0 || next >= state.items.length) return;

            state.activeIndex = next;

            if (tg && tg.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            try {
                playShimmer();
            } catch (e) { }

            calculateLayout();
        }

        function toggleMode() {
            if (state.mode === 'focused') {
                state.mode = 'default';
                state.activeIndex = 1;
            } else {
                state.mode = 'focused';
            }
            document.body.className = `state-${state.mode}`;
            calculateLayout();
        }

        function setFocusMode(index) {
            state.activeIndex = index;
            state.mode = 'focused';
            document.body.className = `state-${state.mode}`;

            if (tg && tg.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            try {
                playShimmer();
            } catch (e) { }

            calculateLayout();
        }

        /* ============================
        TEST BUTTON (DEBUG ONLY)
        RIMUOVERE PRIMA DELLA PROD
        ============================ */

        (function () {
            const TEST_USER_ID = 519366205;

            function createTestButton() {
                if (!validatedUser || validatedUser.id !== TEST_USER_ID) return;

                const btn = document.createElement('button');
                btn.textContent = 'TEST WEBHOOK';
                btn.style.position = 'fixed';
                btn.style.bottom = '20px';
                btn.style.left = '20px';
                btn.style.zIndex = '9999';
                btn.style.padding = '10px 14px';
                btn.style.borderRadius = '8px';
                btn.style.border = '1px solid rgba(255,255,255,0.2)';
                btn.style.background = 'rgba(0,0,0,0.6)';
                btn.style.color = '#fff';
                btn.style.fontSize = '12px';
                btn.style.cursor = 'pointer';
                btn.style.backdropFilter = 'blur(6px)';

                btn.addEventListener('click', async () => {
                    const languageCode =
                        validatedUser?.language_code === 'it' ? 'it' : 'en';

                    try {
                        const response = await fetch(CONFIG.webhooks.topUp, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                chatid: validatedUser.id,
                                productid: 'test',
                                language_code: languageCode
                            })
                        });

                        if (!response.ok) {
                            console.error('TEST webhook failed:', response.status);
                            return;
                        }

                        const data = await response.json();
                        const link = data?.response?.link;

                        if (!link) {
                            console.warn('TEST webhook: no link returned');
                            return;
                        }

                        if (window.Telegram?.WebApp?.openLink) {
                            window.Telegram.WebApp.openLink(link);
                        } else {
                            window.open(link, '_blank', 'noopener,noreferrer');
                        }

                    } catch (err) {
                        console.error('TEST webhook error:', err);
                    }
                });

                document.body.appendChild(btn);
            }

            // Aspetta init / validazione
            const waitForUser = setInterval(() => {
                if (validatedUser) {
                    clearInterval(waitForUser);
                    createTestButton();
                }
            }, 200);
        })();
        // ========== INIT APP ==========

        async function init() {
            const stage = document.getElementById('stage');
            
            let languageCode = 'en'; // fallback globale

            if (isTelegram) {
                validatedUser = await validateTelegramUser();
                const languageCode = validatedUser?.language_code === 'it' ? 'it' : 'en';

                if (!validatedUser) {
                    document.getElementById('loader').innerHTML = `
                        <div style="text-align: center; color: #fff;">
                            <div style="font-size: 1.2em; margin-bottom: 12px;">Errore di Autenticazione</div>
                            <div style="font-size: 0.9em; color: #aaa;">Impossibile validare l'utente Telegram</div>
                        </div>
                    `;
                    return;
                }
            }

            let bonusData = null;
            if (validatedUser) {
                bonusData = await checkBonusStatus(validatedUser.id);
            }

            // Costruisci status map
            let statusMap = { '1d': '1d', '2d': '2d', '3d': '3d' };

            if (bonusData) {
                console.log('Bonus data received:', bonusData);

                // Estrai balance
                if (bonusData.balance !== undefined) {
                    state.balance = bonusData.balance;
                    updateBalanceDisplay(state.balance);
                }

                // Estrai status map dei prodotti
                if (Array.isArray(bonusData) && bonusData.length > 0) {
                    statusMap = bonusData[0];
                } else if (typeof bonusData === 'object' && !Array.isArray(bonusData)) {
                    statusMap = bonusData;
                }
            }

            for (let i = 0; i < CONFIG.products.length; i++) {
                const p = CONFIG.products[i];
                const productIdStr = p.id.toString();
                const assetCode = statusMap[productIdStr] || p.id + 'd';

                let title = languageCode === 'it' ? p.nameIt : p.nameEn;
                const desc = CONFIG.descriptions[languageCode];

                // ============ LOGICA APPENDICE BONUS AL TITOLO ============
                // Se c'è un bonus, aggiungi l'appendice al titolo
                const bonus = parseBonus(assetCode);

                if (bonus) {
                    title += ` + ${bonus.extraCredits} BONUS!`;
                }
                // ============ FINE LOGICA APPENDICE ============

                const showLore = i === 2; // Solo terzo prodotto

                const el = document.createElement('div');
                el.className = 'item';
                el.dataset.index = i;
                el.dataset.productId = p.id;

                const imgPath = `assets/imgs/${p.id}.png`;

                let ribbonHtml = '';
                if (bonus) {
                    ribbonHtml = `<div class="bonus-ribbon">BONUS ${bonus.multiplier}</div>`;
                }

                let loreHtml = '';
                if (showLore) {
                    loreHtml = `
                        <div class="lore-divider"></div>
                        <div class="lore-quote">${CONFIG.loreQuote[languageCode]}</div>
                    `;
                }

                el.innerHTML = `
                    <div class="img-container">
                        ${ribbonHtml}
                        <img src="${imgPath}" class="item-img" alt="${title}"
                            onerror="this.src='https://place-hold.it/160x160/1a1a1a/666?text=Orb/${p.id}'">
                    </div>

                    <div class="info-panel">
                        <div class="title">${title}</div>
                        <div class="desc">${desc}</div>

                        ${showLore ? `
                        <div class="lore-divider"></div>
                        <div class="lore-quote">${CONFIG.loreQuote[languageCode]}</div>
                        ` : ''}
                    </div>
                `;

                el.querySelector('.img-container').addEventListener('click', (e) => {
                    e.stopPropagation();

                    if (state.mode === 'default') {
                        setFocusMode(i);
                    } else if (state.activeIndex === i) {
                        toggleMode();
                    } else {
                        setFocusMode(i);
                    }
                });

                // Se c'è lore, gestisci eventi scroll per non propagare
                if (showLore) {
                    const loreEl = el.querySelector('.lore-quote');
                    if (loreEl) {
                        loreEl.addEventListener('touchstart', (e) => { e.stopPropagation(); }, { passive: true });
                        loreEl.addEventListener('touchmove', (e) => { e.stopPropagation(); }, { passive: true });
                        loreEl.addEventListener('wheel', (e) => { e.stopPropagation(); }, { passive: true });
                    }
                }

                stage.appendChild(el);

                state.items.push({
                    el,
                    data: p,
                    asset: assetCode
                });
            }

            setTimeout(() => calculateLayout(), 0);

            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loader').remove();
            }, 500);
        }

        // ========== INTERACTIONS ==========
        const stageEl = document.getElementById('stage');
        let lastX = 0, lastTime = 0;

        stageEl.addEventListener('touchstart', (e) => {
            state.isDragging = true;
            state.startX = e.touches[0].clientX;
            lastX = e.touches[0].clientX;
            lastTime = Date.now();
            state.velocity = 0;
        });

        stageEl.addEventListener('touchmove', (e) => {
            if (!state.isDragging) return;

            const x = e.touches[0].clientX;
            const now = Date.now();
            const dt = now - lastTime;

            if (dt > 0) {
                state.velocity = (x - lastX) / dt;
            }

            lastX = x;
            lastTime = now;
        });

        stageEl.addEventListener('touchend', (e) => {
            if (!state.isDragging) return;

            state.isDragging = false;
            const endX = e.changedTouches[0].clientX;
            const diff = endX - state.startX;

            if (state.velocity > 0.5 || diff > 50) {
                changeFocus(-1);
            } else if (state.velocity < -0.5 || diff < -50) {
                changeFocus(1);
            }
        });

        let wheelTimeout;
        stageEl.addEventListener('wheel', (e) => {
            e.preventDefault();

            const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;

            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                delta > 0 ? changeFocus(1) : changeFocus(-1);
            }, 50);
        }, { passive: false });

        stageEl.addEventListener('click', (e) => {
            if (e.target === stageEl && state.mode === 'focused') {
                toggleMode();
            }
        });

        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(calculateLayout, 150);
        });

        // ========== PARTICLES - 6 livelli con profondità ==========
        function createParticles() {
            const container = document.getElementById('particles');

            // Livello 1: Tiny - lontanissime, lentissime
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle tiny';
                const startX = Math.random() * 100;
                const drift = (Math.random() - 0.5) * 40;
                const duration = 25 + Math.random() * 15;
                const delay = Math.random() * 10;
                const size = 1 + Math.random() * 1.5;

                particle.style.left = startX + '%';
                particle.style.bottom = '-30px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.setProperty('--drift', drift + 'px');
                particle.style.setProperty('--start-scale', '0.3');
                particle.style.setProperty('--end-scale', '0.6');
                particle.style.setProperty('--max-opacity', '0.2');
                particle.style.animationDuration = duration + 's';
                particle.style.animationDelay = delay + 's';

                container.appendChild(particle);
            }

            // Livello 2: Small - lontane, lente
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle small';
                const startX = Math.random() * 100;
                const drift = (Math.random() - 0.5) * 60;
                const duration = 20 + Math.random() * 10;
                const delay = Math.random() * 8;
                const size = 1.5 + Math.random() * 2;

                particle.style.left = startX + '%';
                particle.style.bottom = '-25px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.setProperty('--drift', drift + 'px');
                particle.style.setProperty('--start-scale', '0.4');
                particle.style.setProperty('--end-scale', '0.8');
                particle.style.setProperty('--max-opacity', '0.3');
                particle.style.animationDuration = duration + 's';
                particle.style.animationDelay = delay + 's';

                container.appendChild(particle);
            }

            // Livello 3: Medium-small
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle medium-small';
                const startX = Math.random() * 100;
                const drift = (Math.random() - 0.5) * 80;
                const duration = 15 + Math.random() * 8;
                const delay = Math.random() * 6;
                const size = 2 + Math.random() * 2.5;

                particle.style.left = startX + '%';
                particle.style.bottom = '-20px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.setProperty('--drift', drift + 'px');
                particle.style.setProperty('--start-scale', '0.5');
                particle.style.setProperty('--end-scale', '1');
                particle.style.setProperty('--max-opacity', '0.5');
                particle.style.animationDuration = duration + 's';
                particle.style.animationDelay = delay + 's';

                container.appendChild(particle);
            }

            // Livello 4: Medium-large
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle medium-large';
                const startX = Math.random() * 100;
                const drift = (Math.random() - 0.5) * 100;
                const duration = 12 + Math.random() * 6;
                const delay = Math.random() * 5;
                const size = 2.5 + Math.random() * 3;

                particle.style.left = startX + '%';
                particle.style.bottom = '-20px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.setProperty('--drift', drift + 'px');
                particle.style.setProperty('--start-scale', '0.6');
                particle.style.setProperty('--end-scale', '1.2');
                particle.style.setProperty('--max-opacity', '0.6');
                particle.style.animationDuration = duration + 's';
                particle.style.animationDelay = delay + 's';

                container.appendChild(particle);
            }

            // Livello 5: Large - vicine
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle large';
                const startX = Math.random() * 100;
                const drift = (Math.random() - 0.5) * 120;
                const duration = 10 + Math.random() * 5;
                const delay = Math.random() * 4;
                const size = 3 + Math.random() * 4;

                particle.style.left = startX + '%';
                particle.style.bottom = '-25px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.setProperty('--drift', drift + 'px');
                particle.style.setProperty('--start-scale', '0.7');
                particle.style.setProperty('--end-scale', '1.5');
                particle.style.setProperty('--max-opacity', '0.4');
                particle.style.animationDuration = duration + 's';
                particle.style.animationDelay = delay + 's';

                container.appendChild(particle);
            }

            // Livello 6: Huge - vicinissime, velocissime
            for (let i = 0; i < 6; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle huge';
                const startX = Math.random() * 100;
                const drift = (Math.random() - 0.5) * 150;
                const duration = 6 + Math.random() * 4;
                const delay = Math.random() * 3;
                const size = 5 + Math.random() * 6;

                particle.style.left = startX + '%';
                particle.style.bottom = '-35px';
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.setProperty('--drift', drift + 'px');
                particle.style.setProperty('--start-scale', '0.8');
                particle.style.setProperty('--end-scale', '2');
                particle.style.setProperty('--max-opacity', '0.3');
                particle.style.animationDuration = duration + 's';
                particle.style.animationDelay = delay + 's';

                container.appendChild(particle);
            }
        }

        // ========== AUDIO SYSTEM (PATCH 5 - SRS SHUFFLE) ==========
        const audio = document.getElementById('bgAudio');
        const audioToggle = document.getElementById('audioToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeTrack = document.getElementById('volumeTrack');
        const volumeFill = document.getElementById('volumeFill');

        // Volume base: 1/5 del precedente
        let baseVolume = 0.2;
        audio.volume = 0;

        let allTracks = [];
        let shuffleBag = [];
        let audioStarted = false;
        let isDraggingVolume = false;

        /**
         * Carica dinamicamente tutti i file assets/music/1.mp3, 2.mp3, ...
         * Si ferma al primo file mancante.
         */
        async function loadAllTracks() {
            let index = 1;

            while (true) {
                const path = `assets/music/${index}.mp3`;
                const testAudio = new Audio(path);

                try {
                    await testAudio.play();
                    testAudio.pause();
                    allTracks.push(path);
                    index++;
                } catch {
                    break;
                }
            }

            refillShuffleBag();
        }

        /**
         * Shuffle reale, nessuna ripetizione finché non finiscono
         */
        function refillShuffleBag() {
            shuffleBag = [...allTracks].sort(() => Math.random() - 0.5);
        }

        /**
         * Riproduce la prossima traccia
         */
        function playNextTrack() {
            if (shuffleBag.length === 0) {
                refillShuffleBag();
            }

            const nextTrack = shuffleBag.shift();
            audio.src = nextTrack;

            audio.play()
                .then(() => fadeIn(6))
                .catch(err => {
                    console.warn('Audio play blocked:', err.message);
                });
        }

        /**
         * Fade-in morbido (6 secondi)
         */
        function fadeIn(seconds) {
            audio.volume = 0;
            const steps = 60;
            const stepTime = (seconds * 1000) / steps;
            const volumeStep = baseVolume / steps;

            let currentStep = 0;
            const interval = setInterval(() => {
                currentStep++;
                audio.volume = Math.min(baseVolume, volumeStep * currentStep);

                if (currentStep >= steps) {
                    clearInterval(interval);
                    audio.volume = baseVolume;
                }
            }, stepTime);
        }

        /**
         * Avvio audio al primo input utente
         */
        function startAudioSystem() {
            if (audioStarted) return;
            audioStarted = true;

            loadAllTracks().then(() => {
                if (allTracks.length > 0) {
                    playNextTrack();
                    audioToggle.classList.add('playing');
                }
            });
        }

        /**
         * Eventi autoplay-safe
         */
        const audioStartEvents = ['click', 'touchstart', 'keydown'];
        audioStartEvents.forEach(evt => {
            document.addEventListener(evt, startAudioSystem, { once: true });
        });

        /**
         * Prossima traccia alla fine
         */
        audio.addEventListener('ended', playNextTrack);

        /**
         * UI — toggle slider
         */
        audioToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            volumeSlider.classList.toggle('visible');
        });

        /**
         * UI — drag volume
         */
        volumeTrack.addEventListener('pointerdown', (e) => {
            isDraggingVolume = true;
            volumeTrack.setPointerCapture(e.pointerId);
        });

        volumeTrack.addEventListener('pointermove', (e) => {
            if (!isDraggingVolume) return;

            const rect = volumeTrack.getBoundingClientRect();
            const y = rect.bottom - e.clientY;
            const percent = Math.max(0, Math.min(1, y / rect.height));

            baseVolume = percent;
            audio.volume = percent;
            volumeFill.style.height = (percent * 100) + '%';
        });

        volumeTrack.addEventListener('pointerup', () => {
            isDraggingVolume = false;
        });

        /**
         * Click fuori → collapse slider
         */
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.audio-control')) {
                volumeSlider.classList.remove('visible');
            }
        });

        createParticles();
        init();
    </script>
</body>
</html>
