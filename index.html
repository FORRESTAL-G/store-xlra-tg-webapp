<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Outsmart Genesis Store</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-bg: var(--tg-theme-bg-color, #000000);
            --tg-text: var(--tg-theme-text-color, #ffffff);
            --accent: #a0a0a0;
            --glow: rgba(100, 149, 237, 0.5); /* CornflowerBlue soft glow */
            --card-width: 220px; /* Fixed width for desktop control */
            --card-height: 280px;
            --transition-speed: 0.6s;
            --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--tg-bg);
            color: var(--tg-text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; /* We handle scroll manually */
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            /* Simulate Telegram Bottom Sheet Radius (Squircle-ish) */
            border-top-left-radius: 22px;
            border-top-right-radius: 22px;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        /* Loader */
        #loader {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--tg-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top-color: var(--tg-text);
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { font-size: 12px; opacity: 0.6; }

        /* Handle */
        .handle-container {
            height: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            background: linear-gradient(to bottom, var(--tg-bg), transparent);
        }
        .handle {
            width: 40px; height: 4px;
            background-color: rgba(255,255,255,0.25);
            border-radius: 2px;
        }

        /* Stage (The interactive area) */
        .stage {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* We don't use overflow hidden here to allow complex absolute positioning */
            overflow: visible; 
            cursor: grab;
            touch-action: none; /* Critical for custom swipe handling */
        }
        .stage:active { cursor: grabbing; }

        /* Product Item */
        .item {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Transitions are applied via JS class toggling for performance, 
               but default styles here */
            will-change: transform, opacity, filter;
            transition: transform var(--transition-speed) var(--ease-out-expo),
                        opacity var(--transition-speed) ease,
                        filter var(--transition-speed) ease;
        }

        /* The Orb Image Container */
        .orb-wrapper {
            width: 180px;
            height: 180px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 2;
        }

        .orb-img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 0 15px var(--glow));
            transition: transform 0.3s ease, filter 0.3s ease;
            pointer-events: none; /* Click passes to wrapper */
        }

        /* Info Text Panel (Title & Desc) */
        .info-panel {
            position: absolute;
            top: 190px; /* Below image */
            width: 240px;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: all var(--transition-speed) ease;
            pointer-events: none;
        }

        .title {
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 6px;
            font-family: 'Times New Roman', serif;
            letter-spacing: 0.5px;
            text-shadow: 0 0 8px rgba(255,255,255,0.2);
        }

        .desc {
            font-size: 0.8em;
            color: #aaa;
            line-height: 1.3;
        }

        /* --- STATES --- */

        /* STATE 1: DEFAULT (Stacked/Flat) */
        .state-default .item {
            /* Handled by JS, but base styles here */
            opacity: 0.8;
            filter: none;
        }
        .state-default .item .info-panel {
            display: none; /* Hide text in default mode to keep it clean */
        }
        .state-default .orb-wrapper:hover .orb-img {
            transform: scale(1.05);
            filter: drop-shadow(0 0 25px var(--glow));
        }

        /* STATE 2: FOCUSED (Vertical Layout) */
        .state-focused .item {
            /* Non-active items */
            opacity: 0.3;
            filter: blur(4px) grayscale(80%);
            transform: scale(0.7);
        }

        .state-focused .item.active {
            opacity: 1;
            filter: blur(0) grayscale(0%);
            transform: scale(1); 
            z-index: 5;
        }
        
        .state-focused .item.active .info-panel {
            opacity: 1;
            transform: translateY(0);
        }

        /* Mobile optimization for Text */
        @media (max-width: 600px) {
            :root { --card-width: 180px; --card-height: 240px; }
            .orb-wrapper { width: 140px; height: 140px; }
            .info-panel { top: 150px; width: 200px; }
            .title { font-size: 1em; }
            .desc { font-size: 0.7em; }
        }
    </style>
</head>
<body class="state-default">

    <!-- Loader -->
    <div id="loader">
        <div class="spinner"></div>
        <div class="loading-text">Loading Assets...</div>
    </div>

    <!-- Handle -->
    <div class="handle-container">
        <div class="handle"></div>
    </div>

    <!-- Interactive Stage -->
    <div id="stage" class="stage">
        <!-- Items will be injected here -->
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        // --- CONFIGURATION ---
        const CONFIG = {
            n8nCheck: 'https://tuo-webhook-n8n.com/check-bonus', // Replace
            n8nPay: 'https://tuo-webhook-n8n.com/generate-payment', // Replace
            // Fallback for testing locally
            testUser: { id: 'TEST_DEV', language_code: 'it' }
        };

        const user = tg.initDataUnsafe.user || CONFIG.testUser;
        const isIt = user.language_code === 'it';

        // --- DATA DEFINITION ---
        const productsDef = [
            { id: 1, price: 50, credits: 400, nameIt: "Genesi x400", nameEn: "Genesis x400" },
            { id: 2, price: 250, credits: 2300, nameIt: "Genesi x2300", nameEn: "Genesis x2300" },
            { id: 3, price: 1000, credits: 10500, nameIt: "Genesi x10500", nameEn: "Genesis x10500" }
        ];

        const descriptions = {
            it: "Orb della Genesi - energia pura necessaria alla manifestazione della tua strategia.",
            en: "Genesis Orb - pure energy necessary to manifest your communication strategy."
        };

        // --- STATE MANAGEMENT ---
        let state = {
            mode: 'default', // 'default' (flat stack) or 'focused' (vertical list)
            activeIndex: 1,  // 0, 1, 2 (Default to middle)
            items: [],       // Stores DOM elements and data
            isDragging: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            lastTime: 0,
            lastX: 0,
            velocity: 0,
            animationFrame: null
        };

        // --- IMAGE PROCESSING: REMOVE WHITE BACKGROUND ---
        // This function draws the image to a canvas, loops through pixels,
        // and makes white pixels transparent.
        async function processImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;

                    // LOOP: Check pixels
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // --- NEW LOGIC ---
                        
                        // 1. Check for White background (High RGB values)
                        const isWhite = (r > 240 && g > 240 && b > 240);
                        
                        // 2. Check for Black background (Low RGB values)
                        // We use a threshold (e.g., 15) to catch near-black pixels
                        const isBlack = (r < 15 && g < 15 && b < 15);

                        if (isWhite || isBlack) {
                            data[i + 3] = 0; // Set Alpha to 0 (Transparent)
                        }
                        
                        // --- OPTIONAL: Glow Enhancement ---
                        // If you want the orb itself to be slightly more opaque or adjust brightness:
                        // if (!isWhite && !isBlack) { data[i+3] = 255; }
                    }

                    ctx.putImageData(imgData, 0, 0);
                    resolve(canvas.toDataURL());
                };
                img.onerror = () => resolve(url);
            });
        }
        // --- INITIALIZATION ---
        async function init() {
            try {
                // 1. Fetch Bonus Status (Mocked for demo, uncomment for prod)
                // const res = await fetch(CONFIG.n8nCheck, ...);
                // const statusMap = await res.json();
                const statusMap = { "1": "1b", "2": "2d", "3": "3b" }; // MOCK

                // 2. Build Data Objects
                const stage = document.getElementById('stage');
                
                for (let i = 0; i < productsDef.length; i++) {
                    const p = productsDef[i];
                    const assetCode = statusMap[p.id];
                    const isBonus = assetCode.includes('b');
                    const imgUrl = `./assets/${assetCode}.png`;

                    // Process Image for Transparency
                    const cleanImgSrc = await processImage(imgUrl);

                    // Texts
                    let title = isIt ? p.nameIt : p.nameEn;
                    if (isBonus) title += " + BONUS!";
                    const desc = isIt ? descriptions.it : descriptions.en;

                    // Create DOM
                    const el = document.createElement('div');
                    el.className = 'item';
                    el.dataset.index = i;
                    el.dataset.id = p.id;
                    el.dataset.asset = assetCode;
                    el.dataset.price = p.price;

                    el.innerHTML = `
                        <div class="orb-wrapper">
                            <img src="${cleanImgSrc}" class="orb-img" alt="Orb ${p.id}">
                        </div>
                        <div class="info-panel">
                            <div class="title">${title}</div>
                            <div class="desc">${desc}</div>
                        </div>
                    `;

                    // Click on Orb to Toggle Mode
                    el.querySelector('.orb-wrapper').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (state.mode === 'default') {
                            setFocusMode(i);
                        } else {
                            // If already focused and clicking the active one
                            if (state.activeIndex === i) toggleMode();
                            else setFocusMode(i);
                        }
                    });

                    stage.appendChild(el);
                    state.items.push({ el, data: p, asset: assetCode });
                }

                // 3. Initial Layout (Default Stack)
                layoutItems();
                updateMainButton();
                
                // Remove Loader
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 500);

            } catch (e) {
                console.error("Init Error", e);
                alert("Error loading store. Please check console.");
            }
        }

        // --- LAYOUT & ANIMATION ENGINE ---
        function layoutItems() {
            const stageW = document.getElementById('stage').clientWidth;
            const stageH = document.getElementById('stage').clientHeight;
            const cardW = 220; // Matches CSS --card-width
            const gap = 20;    // Spacing
            const verticalGap = 140; // Spacing in Focus mode

            state.items.forEach((item, i) => {
                const el = item.el;
                
                if (state.mode === 'default') {
                    // Horizontal Stack Layout (Centered)
                    // Position relative to center
                    const offset = (i - state.activeIndex) * (cardW + gap);
                    const x = (stageW / 2) - (cardW / 2) + offset;
                    const y = (stageH / 2) - 100; // Slightly above center

                    el.style.transform = `translate(${x}px, ${y}px) scale(1)`;
                    el.style.opacity = (i === state.activeIndex) ? '1' : '0.5';
                    el.style.filter = (i === state.activeIndex) ? 'none' : 'blur(2px)';
                    el.classList.remove('active');

                } else {
                    // Focus Mode (Vertical List with Active Left)
                    const isActive = (i === state.activeIndex);
                    
                    if (isActive) {
                        // Active item moves left and stays center vertically
                        const x = (stageW / 2) - (cardW / 2) - 50; // Shift left
                        const y = (stageH / 2) - 140; // Top half
                        el.style.transform = `translate(${x}px, ${y}px) scale(1)`;
                        el.classList.add('active');
                    } else {
                        // Inactive items move down
                        // Calculate how many items down or up relative to active
                        const distance = i - state.activeIndex;
                        // Only show above/below logic
                        const y = (stageH / 2) - 140 + (distance * verticalGap);
                        const x = (stageW / 2) - (cardW / 2) + 40; // Slightly right/behind
                        
                        el.style.transform = `translate(${x}px, ${y}px) scale(0.85)`;
                        el.classList.remove('active');
                    }
                }
            });
        }

        // --- INTERACTION HANDLERS (SWIPE & WHEEL) ---

        const stage = document.getElementById('stage');

        // TOUCH EVENTS (Mobile)
        stage.addEventListener('touchstart', (e) => {
            state.isDragging = true;
            state.startX = e.touches[0].clientX;
            state.startY = e.touches[0].clientY;
            state.lastX = e.touches[0].clientX;
            state.lastTime = Date.now();
            state.velocity = 0;
        }, { passive: true });

        stage.addEventListener('touchmove', (e) => {
            if (!state.isDragging) return;
            state.currentX = e.touches[0].clientX;
            state.currentY = e.touches[0].clientY;
            
            // Calculate Velocity
            const now = Date.now();
            const dt = now - state.lastTime;
            if (dt > 0) {
                const dx = state.currentX - state.lastX;
                state.velocity = dx / dt; // px per ms
            }
            state.lastX = state.currentX;
            state.lastTime = now;

            // Visual feedback during drag (optional, but good for feel)
            // For this demo, we let the native scroll lock handle visuals 
            // until release.
        }, { passive: true });

        stage.addEventListener('touchend', handleSwipeEnd);
        stage.addEventListener('touchcancel', handleSwipeEnd);

        function handleSwipeEnd(e) {
            if (!state.isDragging) return;
            state.isDragging = false;

            const endX = e.changedTouches ? e.changedTouches[0].clientX : state.currentX;
            const diff = endX - state.startX;
            const threshold = 50; // Min distance to trigger change
            const absDiff = Math.abs(diff);

            // If velocity is high, snap based on direction
            // Otherwise snap based on distance
            if (state.velocity > 0.5 || (diff > threshold && Math.abs(diff) > 10)) {
                changeFocus(-1); // Swipe Right -> Go Left (Index -1)
            } else if (state.velocity < -0.5 || (diff < -threshold && Math.abs(diff) > 10)) {
                changeFocus(1);  // Swipe Left -> Go Right (Index +1)
            } else {
                // Snap back to current
                layoutItems();
            }
        }

        // MOUSE WHEEL (Desktop)
        let wheelTimeout;
        stage.addEventListener('wheel', (e) => {
            e.preventDefault(); // Stop actual page scroll
            
            // Debounce the wheel to detect direction
            clearTimeout(wheelTimeout);
            
            // Determine direction (Y axis is usually vertical scroll, 
            // but horizontal scroll is also possible)
            const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;

            wheelTimeout = setTimeout(() => {
                if (delta > 0) changeFocus(1); // Wheel Down/Right
                else changeFocus(-1); // Wheel Up/Left
            }, 50); // Small delay to catch rapid ticks
        }, { passive: false });

        // Click background to toggle mode
        stage.addEventListener('click', (e) => {
            if(e.target === stage && state.mode === 'focused') {
                toggleMode();
            }
        });

        // --- LOGIC ---

        function setFocusMode(index) {
            if (state.mode === 'focused' && state.activeIndex === index) return;
            state.mode = 'focused';
            state.activeIndex = index;
            document.body.className = 'state-focused';
            
            layoutItems();
            updateMainButton();
            tg.HapticFeedback.impactOccurred('light');
        }

        function toggleMode() {
            if (state.mode === 'default') {
                state.mode = 'focused'; // Default to focus on center item if clicked
                document.body.className = 'state-focused';
            } else {
                state.mode = 'default';
                document.body.className = 'state-default';
            }
            layoutItems();
            updateMainButton();
        }

        function changeFocus(direction) {
            const newIndex = state.activeIndex + direction;
            
            // Bounds check
            if (newIndex < 0 || newIndex >= state.items.length) {
                return; // Don't move
            }

            // Ensure we are in focused mode when moving
            if (state.mode === 'default') {
                setFocusMode(newIndex);
                return;
            }

            state.activeIndex = newIndex;
            layoutItems();
            updateMainButton();
            tg.HapticFeedback.selectionChanged();
        }

        // --- MAIN BUTTON ---
        function updateMainButton() {
            const item = state.items[state.activeIndex];
            if (!item) return;

            const priceLabel = item.data.price;
            const text = isIt ? `ACQUISTA ORB - ${priceLabel} CHF` : `BUY ORB - ${priceLabel} CHF`;
            
            tg.MainButton.setText(text);
            tg.MainButton.show();
            
            // Remove old listeners
            tg.MainButton.offClick(handlePayment); 
            tg.MainButton.onClick(handlePayment);
        }

        async function handlePayment() {
            const item = state.items[state.activeIndex];
            
            // Vibration
            tg.HapticFeedback.notificationOccurred('success');
            tg.MainButton.showProgress();

            // Prepare Payload
            const payload = {
                tg_id: user.id,
                tier_id: item.data.id,
                asset_code: item.asset
            };

            try {
                // Uncomment for real request:
                /*
                const res = await fetch(CONFIG.n8nPay, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                */

                // MOCK RESPONSE (Remove this block in production)
                const data = { url: 'https://stripe.com/pay/example' }; 
                
                if (data.url) {
                    // Wait a tiny bit for the progress animation
                    setTimeout(() => {
                        Telegram.WebApp.openLink(data.url);
                        tg.MainButton.hideProgress();
                    }, 800);
                } else {
                    throw new Error("No URL returned");
                }

            } catch (err) {
                console.error(err);
                tg.MainButton.hideProgress();
                alert("Errore generazione link di pagamento.");
            }
        }

        // Run
        init();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            // Debounce resize
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(layoutItems, 100);
        });

    </script>
</body>
</html>
