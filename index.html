    <script>
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        // --- CONFIGURATION ---
        const CONFIG = {
            n8nCheck: 'https://tuo-webhook-n8n.com/check-bonus',
            n8nPay: 'https://tuo-webhook-n8n.com/generate-payment',
            testUser: { id: 'TEST_DEV', language_code: 'it' }
        };

        const user = tg.initDataUnsafe.user || CONFIG.testUser;
        const isIt = user.language_code === 'it';

        // --- DATA DEFINITION ---
        const productsDef = [
            { id: 1, price: 50, credits: 400, nameIt: "Genesi x400", nameEn: "Genesis x400" },
            { id: 2, price: 250, credits: 2300, nameIt: "Genesi x2300", nameEn: "Genesis x2300" },
            { id: 3, price: 1000, credits: 10500, nameIt: "Genesi x10500", nameEn: "Genesis x10500" }
        ];

        const descriptions = {
            it: "Orb della Genesi - energia pura necessaria alla manifestazione della tua strategia.",
            en: "Genesis Orb - pure energy necessary to manifest your communication strategy."
        };

        // --- STATE MANAGEMENT ---
        let state = {
            mode: 'default',
            activeIndex: 1,
            items: [],
            isDragging: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            lastTime: 0,
            lastX: 0,
            velocity: 0,
            animationFrame: null
        };

        // --- IMAGE PROCESSING: REMOVE WHITE OR BLACK BACKGROUND ---
        async function processImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = url;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        const isWhite = (r > 240 && g > 240 && b > 240);
                        const isBlack = (r < 15 && g < 15 && b < 15);

                        if (isWhite || isBlack) {
                            data[i + 3] = 0;
                        }
                    }

                    ctx.putImageData(imgData, 0, 0);
                    resolve(canvas.toDataURL());
                };
                img.onerror = () => resolve(url);
            });
        }

        // --- INITIALIZATION ---
        async function init() {
            try {
                // const res = await fetch(CONFIG.n8nCheck, ...);
                // const statusMap = await res.json();
                const statusMap = { "1": "1b", "2": "2d", "3": "3b" }; // MOCK

                const stage = document.getElementById('stage');
                
                for (let i = 0; i < productsDef.length; i++) {
                    const p = productsDef[i];
                    const assetCode = statusMap[p.id];
                    const isBonus = assetCode.includes('b');
                    const imgUrl = `./assets/${assetCode}.png`;

                    const cleanImgSrc = await processImage(imgUrl);

                    let title = isIt ? p.nameIt : p.nameEn;
                    if (isBonus) title += " + BONUS!";
                    const desc = isIt ? descriptions.it : descriptions.en;

                    const el = document.createElement('div');
                    el.className = 'item';
                    el.dataset.index = i;
                    el.dataset.id = p.id;
                    el.dataset.asset = assetCode;
                    el.dataset.price = p.price;

                    el.innerHTML = `
                        <div class="orb-wrapper">
                            <img src="${cleanImgSrc}" class="orb-img" alt="Orb ${p.id}">
                        </div>
                        <div class="info-panel">
                            <div class="title">${title}</div>
                            <div class="desc">${desc}</div>
                        </div>
                    `;

                    el.querySelector('.orb-wrapper').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (state.mode === 'default') {
                            setFocusMode(i);
                        } else {
                            if (state.activeIndex === i) toggleMode();
                            else setFocusMode(i);
                        }
                    });

                    stage.appendChild(el);
                    state.items.push({ el, data: p, asset: assetCode });
                }

                layoutItems();
                updateMainButton();
                
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 500);

            } catch (e) {
                console.error("Init Error", e);
                alert("Error loading store. Please check console.");
            }
        }

        // --- LAYOUT & ANIMATION ENGINE ---
        function layoutItems() {
            const stage = document.getElementById('stage');
            const stageW = stage.clientWidth;
            const stageH = stage.clientHeight;

            const cardW = 220;
            const gap = 20;
            const verticalGap = 140;

            state.items.forEach((item, i) => {
                const el = item.el;
                
                if (state.mode === 'default') {
                    const offset = (i - state.activeIndex) * (cardW + gap);
                    const x = (stageW / 2) - (cardW / 2) + offset;
                    const y = (stageH / 2) - (280 / 2); 

                    // In modalità DEFAULT: Nessun blur, nessuna scala ridotta
                    el.style.transform = `translate(${x}px, ${y}px) scale(1)`;
                    el.style.opacity = (i === state.activeIndex) ? '1' : '0.8'; // Leggera opacità
                    el.style.filter = 'none'; // RIMOSSO IL BLUR
                    el.classList.remove('active');

                } else {
                    // MODALITÁ ACTIVE (Focused)
                    const isActive = (i === state.activeIndex);
                    
                    if (isActive) {
                        const x = (stageW / 2) - (cardW / 2) - 50;
                        const y = (stageH / 2) - (280 / 2) - 20;
                        el.style.transform = `translate(${x}px, ${y}px) scale(1)`;
                        el.style.filter = 'blur(0) grayscale(0%)';
                        el.classList.add('active');
                    } else {
                        const distance = i - state.activeIndex;
                        const y = (stageH / 2) - (280 / 2) - 20 + (distance * verticalGap);
                        const x = (stageW / 2) - (cardW / 2) + 40;
                        
                        // In modalità ACTIVE, i non attivi hanno blur e scala ridotta
                        el.style.transform = `translate(${x}px, ${y}px) scale(0.85)`;
                        el.style.filter = 'blur(4px) grayscale(80%)';
                        el.style.opacity = '0.3';
                        el.classList.remove('active');
                    }
                }
            });
        }

        // --- INTERACTION HANDLERS (SWIPE & WHEEL) ---
        const stage = document.getElementById('stage');

        // TOUCH EVENTS
        stage.addEventListener('touchstart', (e) => {
            state.isDragging = true;
            state.startX = e.touches[0].clientX;
            state.startY = e.touches[0].clientY;
            state.lastX = e.touches[0].clientX;
            state.lastTime = Date.now();
            state.velocity = 0;
        }, { passive: true });

        stage.addEventListener('touchmove', (e) => {
            if (!state.isDragging) return;
            state.currentX = e.touches[0].clientX;
            state.currentY = e.touches[0].clientY;
            
            const now = Date.now();
            const dt = now - state.lastTime;
            if (dt > 0) {
                const dx = state.currentX - state.lastX;
                state.velocity = dx / dt;
            }
            state.lastX = state.currentX;
            state.lastTime = now;
        }, { passive: true });

        stage.addEventListener('touchend', handleSwipeEnd);
        stage.addEventListener('touchcancel', handleSwipeEnd);

        function handleSwipeEnd(e) {
            if (!state.isDragging) return;
            state.isDragging = false;

            const endX = e.changedTouches ? e.changedTouches[0].clientX : state.currentX;
            const diff = endX - state.startX;
            const threshold = 50; 

            if (state.velocity > 0.5 || (diff > threshold && Math.abs(diff) > 10)) {
                changeFocus(-1); 
            } else if (state.velocity < -0.5 || (diff < -threshold && Math.abs(diff) > 10)) {
                changeFocus(1); 
            } else {
                layoutItems();
            }
        }

        // MOUSE WHEEL (Desktop)
        let wheelTimeout;
        stage.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            
            const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;

            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                if (delta > 0) changeFocus(1);
                else changeFocus(-1);
            }, 50);
        }, { passive: false });

        stage.addEventListener('click', (e) => {
            if(e.target === stage && state.mode === 'focused') {
                toggleMode();
            }
        });

        // --- LOGIC ---
        function setFocusMode(index) {
            if (state.mode === 'focused' && state.activeIndex === index) return;
            state.mode = 'focused';
            state.activeIndex = index;
            document.body.className = 'state-focused';
            
            layoutItems();
            updateMainButton();
            tg.HapticFeedback.impactOccurred('light');
        }

        function toggleMode() {
            if (state.mode === 'default') {
                state.mode = 'focused';
                document.body.className = 'state-focused';
            } else {
                state.mode = 'default';
                document.body.className = 'state-default';
            }
            layoutItems();
            updateMainButton();
        }

        function changeFocus(direction) {
            const newIndex = state.activeIndex + direction;
            
            if (newIndex < 0 || newIndex >= state.items.length) return;

            if (state.mode === 'default') {
                setFocusMode(newIndex);
                return;
            }

            state.activeIndex = newIndex;
            layoutItems();
            updateMainButton();
            tg.HapticFeedback.selectionChanged();
        }

        // --- MAIN BUTTON ---
        function updateMainButton() {
            const item = state.items[state.activeIndex];
            if (!item) return;

            const priceLabel = item.data.price;
            const text = isIt ? `ACQUISTA ORB - ${priceLabel} CHF` : `BUY ORB - ${priceLabel} CHF`;
            
            tg.MainButton.setText(text);
            tg.MainButton.show();
            
            tg.MainButton.offClick(handlePayment); 
            tg.MainButton.onClick(handlePayment);
        }

        async function handlePayment() {
            const item = state.items[state.activeIndex];
            
            tg.HapticFeedback.notificationOccurred('success');
            tg.MainButton.showProgress();

            const payload = {
                tg_id: user.id,
                tier_id: item.data.id,
                asset_code: item.asset
            };

            try {
                // UNCOMMENT FOR PRODUCTION
                /*
                const res = await fetch(CONFIG.n8nPay, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                */

                const data = { url: 'https://stripe.com/pay/example' }; 
                
                if (data.url) {
                    setTimeout(() => {
                        Telegram.WebApp.openLink(data.url);
                        tg.MainButton.hideProgress();
                    }, 800);
                } else {
                    throw new Error("No URL returned");
                }

            } catch (err) {
                console.error(err);
                tg.MainButton.hideProgress();
                alert("Errore generazione link di pagamento.");
            }
        }

        // Run
        init();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(layoutItems, 100);
        });

    </script>